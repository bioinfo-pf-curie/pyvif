# coding: utf-8

""" A second version of breakpoint detection

I detect breakpoint with the minimap2 mapping and breakpoints sequences.
"""

from collections import OrderedDict

import pandas as pd
from atropos.io.seqio import FastqReader

from . import logger
from .exception import BadInputException
from .paftools import PAF

TRANSTAB = str.maketrans("ACGTacgt", "TGCAtgca")


class BreakpointFinder(object):
    """ Object that detect all breakpoint present in PacBio data.
    It uses a mapping on human and viruses genomes.
    """
    def __init__(self, raw, human, interest):
        """.. rubric:: constructor

        :param raw: Raw fastq data.
        :param human: PAF* format of mapping on human genome or BAM file.
        :param interest: PAF* format of mapping on interest genomes or BAM file.

        *PAF correspond to :class:`pbcapture.bamtools.PAF` object or a PAF
        file created by :meth:`pbcapture.bamtools.PAF.to_csv`.
        """
        self.raw = raw
        self.paf, self.interest_contigs = self._init_paf(human, interest)

    def _init_paf(self, human, interest):
        """ Initiate intersect paf with alignment on human and on target.
        Only reads that maps on interest genomes are kept.

        Return merged PAFs as a :class:`pd.DataFrame` and contigs of interest.
        """
        human_paf = self._create_paf_format(human)
        interest_paf = self._create_paf_format(interest)

        # get human alignment of reads HPV+
        interest_reads_name = interest_paf['q_name'].unique()
        human_align = human_paf.loc[human_paf['q_name'].isin(interest_reads_name)]

        paf = pd.concat([human_align, interest_paf])
        paf = paf.sort_values(["q_name", "q_start"])
        paf = paf.set_index("q_name")
        return paf, interest_paf["chr"].unique().tolist()

    def _create_paf_format(self, filin):
        """ The class can be init with BAM file or PAF format generated by
            :class:`pbcapture.bamtools.PAF`.

            Return the PAF as a :class:`pd.DataFrame`.
        """
        # Check DataFrame and bamfile
        try:
            return PAF(filin).df
        except BadInputException:
            pass
        # Check PAF format
        try:
            filin.number_mapped_reads()
        except AttributeError:
            pass
        msg = "No correct input provided."
        raise BadInputException(msg)

    def find_breakpoints(self):
        """ Find all breakpoints between the reference and the contig of
        interest.
        """
        logger.info("Breakpoint research is running...")
        breakpoints = list()
        with FastqReader(self.raw) as filin:
            for record in filin:
                try:
                    breakpoints += self._get_read_breakpoints(record.name,
                                                              record.sequence)
                except TypeError:
                    pass
        logger.info("{} breakpoints are found.".format(len(breakpoints)))
        return pd.DataFrame(breakpoints)

    def _get_read_breakpoints(self, name, sequence):
        try:
            read_paf = self.paf.loc[name]
        except KeyError:
            return
        # zip function is faster than itertuples method
        # try if read_paf is a dataframe and not a Series
        # If it is a Serie -> read have only one alignment
        try:
            iter_align = zip(
                read_paf["chr"], read_paf["r_start"], read_paf["r_end"],
                read_paf["q_start"], read_paf["q_end"], read_paf["strand"],
                read_paf["mapq"]
            )
        except TypeError:
            return

        # init previous variables
        prev_chr = prev_coord = prev_strand = prev_mapq = None
        bp_list = list()

        # find breakpoint in read
        for cur_chr, *cur_coord, cur_strand, cur_mapq in iter_align:
            if cur_chr in self.interest_contigs:
                if prev_chr != cur_chr:
                    try:
                        bp_list.append(
                            self._get_breakpoint(
                                prev_chr, prev_coord, prev_strand,
                                prev_mapq, cur_chr, cur_coord,
                                cur_strand, name, sequence
                            )
                        )
                    except TypeError:
                        pass
            elif prev_chr in self.interest_contigs:
                try:
                    bp_list.append(
                        self._get_breakpoint(
                            cur_chr, cur_coord, cur_strand, cur_mapq, prev_chr,
                            prev_coord, prev_strand, name, sequence
                        )
                    )
                except TypeError:
                    pass
            (prev_chr, prev_coord, prev_strand, prev_mapq) = (
                cur_chr, cur_coord, cur_strand, cur_mapq)
        return bp_list

    def _get_breakpoint(self, human_chr, human_coord, human_strand, human_mapq,
                        interest_chr, interest_coord, interest_strand,
                        read_name, read_seq):
        """ Create breakpoint dictionnary to create dataframe.
        """
        # check if hg - hpv or hpv - hg case
        i = 0 if human_coord[2] < interest_coord[2] else 1

        # get coord if strand is '+'
        too_far = abs(human_coord[3 - i] - interest_coord[2 + i]) > 20
        if human_mapq > 20 and not too_far:
            bpstart_human = human_coord[1 - i]
            end_human = human_coord[0 + i]
        else:
            human_chr = bpstart_human = end_human = "Unknown"
        bpstart_interest = interest_coord[0 + i]
        end_interest = interest_coord[1 - i]

        # switch start / end if strand is '-'
        if human_strand == '-':
            bpstart_human, end_human = end_human, bpstart_human
        if interest_strand == '-':
            bpstart_interest, end_interest = end_interest, bpstart_interest

        # get 30 bases of sequence
        bp_pos = interest_coord[2 + i]
        bp_sequence = read_seq[bp_pos - 15:bp_pos + 15]
        if interest_strand == '-':
            bp_sequence = bp_sequence.translate(TRANSTAB)[::-1]

        return OrderedDict([
            ("chromosome", human_chr),
            ("bpstart_human", bpstart_human),
            ("end_human", end_human),
            ("interest_contig", interest_chr),
            ("bpstart_interest", bpstart_interest),
            ("end_interest", end_interest),
            ("read", read_name),
            ("bp_sequence", bp_sequence)
        ])


if __name__ == "__main__":
    bp_finder = BreakpointFinder(
        "interest_reads.fastq",
        "human.bam",
        "interest.bam"
    )
    breakpoint_df = bp_finder.find_breakpoints()
