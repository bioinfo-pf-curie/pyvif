# coding: utf-8

""" A second version of breakpoint detection

I detect breakpoint with the minimap2 mapping and breakpoints sequences.
"""

from collections import OrderedDict

import pandas as pd
from atropos.io.seqio import FastqReader

from . import logger
from .exception import BadInputException
from .paftools import PAF

_TRANSTAB = str.maketrans("ACGTacgt", "TGCAtgca")


class BreakpointFinder(object):
    """ Object that detect all breakpoint present in PacBio data.
    It uses a mapping on human and viruses genomes.
    """
    def __init__(self, raw, human, interest):
        """.. rubric:: constructor

        :param raw: Raw fastq data.
        :param human: PAF* format of mapping on human genome or BAM file.
        :param interest: PAF* format of mapping on interest genomes or BAM file.

        *PAF correspond to :class:`pbcapture.bamtools.PAF` object or a PAF
        file created by :meth:`pbcapture.bamtools.PAF.to_csv`.
        """
        self.raw = raw
        self.paf, self.interest_contigs = self._init_paf(human, interest)
        self.palindromics = []
        self.bps = self.find_breakpoints()

    def _init_paf(self, human, interest):
        """ Initiate intersect paf with alignment on human and on target.
        Only reads that maps on interest genomes are kept.

        Return merged PAFs as a :class:`pd.DataFrame` and contigs of interest.
        """
        human_paf = self._create_paf_format(human)
        interest_paf = self._create_paf_format(interest)

        # get human alignment of reads HPV+
        interest_reads_name = interest_paf['q_name'].unique()
        human_align = human_paf.loc[human_paf['q_name'].isin(interest_reads_name)]

        paf = pd.concat([human_align, interest_paf])
        paf = paf.sort_values(["q_name", "q_start"])
        paf = paf.set_index("q_name")
        return paf, interest_paf["chr"].unique().tolist()

    def _create_paf_format(self, filin):
        """ The class can be init with BAM file or PAF format generated by
            :class:`pbcapture.bamtools.PAF`.

            Return the PAF as a :class:`pd.DataFrame`.
        """
        # Check DataFrame and bamfile
        try:
            return PAF(filin).df
        except BadInputException:
            pass
        # Check PAF format
        try:
            filin.number_mapped_reads()
        except AttributeError:
            pass
        msg = "No correct input provided."
        raise BadInputException(msg)

    def find_breakpoints(self):
        """ Find all breakpoints between the reference and the contig of
        interest.
        """
        logger.info("Breakpoint research is running...")
        self.palindromics = []
        breakpoints = list()
        with FastqReader(self.raw) as filin:
            for record in filin:
                try:
                    breakpoints += self._get_read_breakpoints(record.name,
                                                              record.sequence)
                except TypeError:
                    pass
        logger.info("{} breakpoints are found.".format(len(breakpoints)))
        return pd.DataFrame(breakpoints)

    def _get_read_breakpoints(self, name, sequence):
        try:
            read_paf = self.paf.loc[name]
        except KeyError:
            return
        # zip function is faster than itertuples method
        # try if read_paf is a dataframe and not a Series
        # If it is a Serie -> read have only one alignment
        try:
            iter_align = zip(
                read_paf["chr"], read_paf["r_start"], read_paf["r_end"],
                read_paf["q_start"], read_paf["q_end"], read_paf["strand"],
                read_paf["mapq"]
            )
        except TypeError:
            return

        # init previous variables
        prev_chr = prev_coord = prev_strand = prev_mapq = None
        bp_list = list()

        # find breakpoint in read
        for cur_chr, *cur_coord, cur_strand, cur_mapq in iter_align:
            if cur_chr in self.interest_contigs:
                if prev_chr != cur_chr:
                    try:
                        bp_list.append(
                            self._get_breakpoint(
                                prev_chr, prev_coord, prev_strand,
                                prev_mapq, cur_chr, cur_coord,
                                cur_strand, name, sequence
                            )
                        )
                    except TypeError:
                        pass
            elif prev_chr in self.interest_contigs:
                try:
                    bp_list.append(
                        self._get_breakpoint(
                            cur_chr, cur_coord, cur_strand, cur_mapq, prev_chr,
                            prev_coord, prev_strand, name, sequence
                        )
                    )
                except TypeError:
                    pass
            (prev_chr, prev_coord, prev_strand, prev_mapq) = (
                cur_chr, cur_coord, cur_strand, cur_mapq)

        # Check if the read is palindromics
        if _read_is_palindromic(bp_list):
            self.palindromics.append(bp_list)
            return []
        return bp_list

    def _get_breakpoint(self, human_chr, human_coord, human_strand, human_mapq,
                        interest_chr, interest_coord, interest_strand,
                        read_name, read_seq):
        """ Create breakpoint dictionnary to create dataframe.
        """
        # check if hg - hpv or hpv - hg case
        i = 0 if human_coord[2] < interest_coord[2] else 1

        # get coord if strand is '+'
        too_far = abs(human_coord[3 - i] - interest_coord[2 + i]) > 20
        if human_mapq > 20 and not too_far:
            bpstart_human = human_coord[1 - i]
            end_human = human_coord[0 + i]
        else:
            human_chr = bpstart_human = end_human = "Unknown"
        bpstart_interest = interest_coord[0 + i]
        end_interest = interest_coord[1 - i]

        # switch start / end if strand is '-'
        if human_strand == '-':
            bpstart_human, end_human = end_human, bpstart_human
        if interest_strand == '-':
            bpstart_interest, end_interest = end_interest, bpstart_interest

        # get 30 bases of sequence
        bp_pos = interest_coord[2 + i]
        bp_sequence = read_seq[bp_pos - 15:bp_pos + 15]
        if interest_strand == '-':
            bp_sequence = bp_sequence.translate(_TRANSTAB)[::-1]

        return OrderedDict([
            ("chromosome", human_chr),
            ("bpstart_human", bpstart_human),
            ("end_human", end_human),
            ("interest_contig", interest_chr),
            ("bpstart_interest", bpstart_interest),
            ("end_interest", end_interest),
            ("read", read_name),
            ("bp_sequence", bp_sequence)
        ])

    def clustering_breakpoints(self, human_thd=25, interest_thd=25):
        """ Generate a clustering with bpstart_human and with bpstart_interest.

        :params int threshold: maximal distance between two breakpoint start.

        Add 'human_clust' and 'interest_clust' in dataframe.
        """
        # clustering with human breakpoint start and chromosome
        known_bp = self.bps.loc[self.bps['chromosome'] != 'Unknown']
        clustering = known_bp.sort_values('bpstart_human')\
                             .groupby('chromosome')['bpstart_human']\
                             .diff().gt(human_thd).cumsum()
        self.bps.loc[clustering.index, 'human_clust'] = clustering
        grouped = self.bps.dropna().groupby(['chromosome', 'human_clust'])
        logger.info("They are {} different breakpoints in human genome."
                    .format(len(grouped.groups)))
        # clustering with interest breakpoint start
        clustering = self.bps.sort_values('bpstart_interest')['bpstart_interest']\
                             .diff().gt(interest_thd).cumsum()
        self.bps.loc[clustering.index, 'interest_clust'] = clustering
        logger.info("They are {} different breakpoints in interest genome."
                    .format(len(self.bps['interest_clust'].unique())))

    def summarize_human_clustering(self, top_cluster=10):
        """ Return a dataframe that summarizes bigger clusters.

        :params int top_cluster: number of bigger cluster to summerize.
        """
        # get groups
        try:
            grouped = self.bps.dropna().groupby(['chromosome', 'human_clust'])
        except KeyError:
            raise KeyError("Run the method `clustering_breakpoints` before"
                           " this method.")
        sorted_group = sorted(grouped.groups.items(), key=lambda x: len(x[1]),
                              reverse=True)
        cluster_df = [
            self._summarize_sub_df(cluster[1])
            for cluster in sorted_group[:top_cluster]
        ]
        return pd.DataFrame(
            cluster_df, 
            columns=['chromosome', 'median_bpstart_human', 'max_end_human',
                     'median_bpstart_interest', 'max_end_interest',
                     'number_of_read']
        )

    def _summarize_sub_df(self, index):
        """ Return a summary of your cluster.
        """
        subdf = self.bps.loc[index]
        return [
            subdf['chromosome'].max(),
            subdf['bpstart_human'].median(),
            _get_max_end(subdf, 'human'),
            subdf['bpstart_interest'].median(),
            _get_max_end(subdf, 'interest'),
            len(index)
        ]


def _get_max_end(subdf, target):
    start = "bpstart_" + target
    end = "end_" + target
    if subdf[start].min() > subdf[end].min():
        return subdf[end].min()
    return subdf[end].max()


def _read_is_palindromic(bp_list):
    """ Check if a read with multiple breakpoint is palindromics.
    """
    if len(bp_list) < 2:
        return False
    bp_iter = iter(bp_list)
    prev_bp = next(bp_iter)
    for bp in bp_iter:
        if _bp_are_equal(prev_bp, bp):
            return True
        prev_bp = bp
    return False


def _bp_are_equal(bp1, bp2, margin=100):
    iter_dict = zip(bp1.items(), bp2.items())
    for (k1, v1), (k2, v2) in iter_dict:
        # ignore sequence
        if k1 == "bp_sequence":
            continue
        # stop parameter need special comparison
        if k1.startswith("end"):
            start = "bpstart_" + k1.split("_")[-1]
            try:
                cond = ((bp1[start] - v1) * (bp2[start] - v2)) > 0
            except TypeError:
                cond = v1 == v2
            if cond:
                continue
            else:
                return False

        # create condition if value are string or int
        try:
            cond = abs(v1 - v2) < margin
        except TypeError:
            cond = v1 == v2
        if cond is False:
            return False
    return True
